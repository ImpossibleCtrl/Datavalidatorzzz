<!doctype html>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Data Validator Console — Single File</title>
<style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#0b1020;color:#e6e6e6} .wrap{max-width:960px;margin:0 auto;padding:24px} .card{background:#141a33;border-radius:12px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.2)} h1{margin:0 0 8px} label{display:block;margin-bottom:6px;color:#9db0ff} input[type=file]{width:100%} button{background:#5b6cff;border:0;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer} .muted{color:#a0a8c8} table{width:100%;border-collapse:collapse;font-size:14px} th,td{text-align:left;padding:8px;border-bottom:1px solid #2a2f4a} thead{background:#1b2140}</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Data Validator Console</h1>
  <div class="muted">Single-file • Spec embedded • Auto-validates on upload • Client-side only</div>
  <div class="card" style="margin-top:12px">
    <label>Upload Data (CSV/XLSX/JSON)</label>
    <input id="dataFile" type="file" accept=".csv,.xls,.xlsx,.json">
    <div id="status" class="muted" style="margin-top:8px">Spec loaded: <span id="specCount">0</span> rules. Waiting for file…</div>
  </div>

  <div class="card" style="margin-top:12px">
    <div><strong>Status:</strong> <span id="state">Idle</span></div>
    <div id="msg" style="margin-top:6px"></div>
  </div>

  <div class="card" style="margin-top:12px">
    <div style="display:flex;gap:8px;justify-content:space-between;align-items:center">
      <div><strong>Issues</strong></div>
      <div><button id="dlIssues" disabled>Download Issues CSV</button> <button id="dlClean" disabled>Download Cleaned CSV</button></div>
    </div>
    <div style="overflow:auto;max-height:420px;margin-top:8px">
      <table><thead><tr><th>Row</th><th>Type</th><th>Field</th><th>Message</th></tr></thead><tbody id="tbody"></tbody></table>
    </div>
  </div>
</div>

<script type="module">
import Ajv from 'https://cdn.jsdelivr.net/npm/ajv@8/dist/ajv.min.js';
import addFormats from 'https://cdn.jsdelivr.net/npm/ajv-formats@3/dist/ajv-formats.min.js';

const SPEC = [{"Field Name": "Site Name", "Required?": "Y", "Requirements": "Filled in & matches the asset name"}, {"Field Name": "Work Zone", "Required?": "Y", "Requirements": "Filled in & matches the asset name"}, {"Field Name": "Building Name", "Required?": "Y", "Requirements": "Filled in & matches the asset name"}, {"Field Name": "Floor", "Required?": "Y", "Requirements": "Filled in & matches the asset name"}, {"Field Name": "Room", "Required?": "Y", "Requirements": "Filled in & matches the asset name"}, {"Field Name": "Status", "Required?": "Y", "Requirements": "Filled in as 'Online' or 'Offline'"}, {"Field Name": "TagID", "Required?": "N", "Requirements": "Must have this OR reason not tagged - enter QR or Barcode placed on asset"}, {"Field Name": "Reason Not Tagged", "Required?": "N", "Requirements": "Must have this OR tagID"}, {"Field Name": "Asset Number", "Required?": "N", "Requirements": "If present, this should be the identifier on placard"}, {"Field Name": "Asset Name", "Required?": "Y", "Requirements": "Fill in blanks, ensure data matches the rest of the asset info & verify correct format: Asset Cateogy-Type-Work Zone-Floor-Room-Standard Acronym. Capitalize All"}, {"Field Name": "Asset Description", "Required?": "Y", "Requirements": "Formatted as 'Asset Cateogry-Asset Type'"}, {"Field Name": "JACS Code", "Required?": "Y", "Requirements": "Matches Asset Category"}, {"Field Name": "JACS Code ID", "Required?": "Y", "Requirements": "Matches JACS Code"}, {"Field Name": "Asset Status", "Required?": "Y", "Requirements": "Set to 'In-Service'"}, {"Field Name": "Asset Record Status", "Required?": "Y", "Requirements": "Set to 'Active'"}, {"Field Name": "Manufacturer", "Required?": "Y", "Requirements": "Filled in & matches photos OR 'No Nameplate Information Available' & verify by looking at photo. Capitalize All"}, {"Field Name": "Model", "Required?": "Y", "Requirements": "Filled in & matches photos OR 'No Nameplate Information Available' & verify by looking at photo. Capitalize All"}, {"Field Name": "Serial", "Required?": "Y", "Requirements": "Filled in & matches photos OR 'No Nameplate Information Available' & verify by looking at photo. Capitalize All"}, {"Field Name": "In-Service Date", "Required?": "Y", "Requirements": "Format: MM/DD/YYYY Enter the date that the asset was installed or manufactured. Steps for getting In-service date: \n-In-service date on nameplate \n-Date of manufacture on nameplate or derived from serial number (https://www.building-center.org/) \n-Date of similar piece of equipment in same space \n-Date of oldest asset in building \n-Date of building construction "}, {"Field Name": "CA-Age", "Required?": "Y", "Requirements": "Enter age based on date in dropdown list"}, {"Field Name": "CA-Condition", "Required?": "Y", "Requirements": "Enter condition from dropdown list"}, {"Field Name": "CA-Environment", "Required?": "Y", "Requirements": "Enter condition from dropdown list"}, {"Field Name": "Capacity Unit", "Required?": "N", "Requirements": "Enter the unit of measure that defines the size or capacity of the asset"}, {"Field Name": "Capacity Quantity", "Required?": "N", "Requirements": "Enter the quantity that defines the size or capacity of the asset, based on the unit of measure selected"}, {"Field Name": "Images", "Required?": "Y", "Requirements": "ALL assets require at least 3 images: one of tag, one of unit and one of unit in its environment. Panelboards and anything electrical with switches require 5 images unless unlabeled or unsafe to open."}];
const specHeader = ["Field","Required","Type","Min","Max","Allowed","Regex","Case","Unique","Trim","NormalizeWhitespace"];
let specRows = cleanSpec(SPEC);
document.getElementById('specCount').textContent = String(specRows.length);

// Build schema/regex immediately
let schema = buildSchemaFromSpec(specRows);
let regexRules = buildRegexFromSpec(specRows);
let dataArray = [];

const el = (id)=> document.getElementById(id);
const setText = (id, v)=> (el(id).textContent = v);

el('dataFile').addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; if(!file) return;
  setText('state','Loading file…');
  const ext = (file.name.split('.').pop()||'').toLowerCase();
  try{
    if(ext==='csv'){
      const txt = await file.text();
      const res = Papa.parse(txt, { header:true, skipEmptyLines:true });
      dataArray = res.data || [];
      setText('status', `Loaded ${dataArray.length} CSV rows.`);
    } else if(['xls','xlsx'].includes(ext)){
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type:'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      dataArray = XLSX.utils.sheet_to_json(ws);
      setText('status', `Loaded ${dataArray.length} XLSX rows.`);
    } else {
      const txt = await file.text();
      const json = JSON.parse(txt);
      dataArray = Array.isArray(json)? json : [json];
      setText('status', `Loaded ${dataArray.length} JSON record(s).`);
    }
  }catch(err){ setText('state','Idle'); el('msg').textContent = 'Load error: '+err; return; }
  // auto-run validation
  await validateNow();
});

async function validateNow(){
  setText('state','Validating…'); el('msg').textContent='';
  const ajv = new Ajv({ allErrors:true, strict:false }); addFormats(ajv);
  const validate = ajv.compile(schema.items || {});
  const regexMap = {}; for(const [f,p] of Object.entries(regexRules||{})){ try{ regexMap[f] = new RegExp(p); }catch{} }
  const issues = []; const cleaned = dataArray.map(r=>({...r}));
  const uniqueFields = new Set(); const trimFields = new Set(); const normWSFields = new Set(); const caseRules = {}; const badRegexFields = [];
  for(const r of specRows){ const f=(r.Field||'').trim(); if(!f) continue; if(asBool(r.Unique)) uniqueFields.add(f); if(asBool(r.Trim)) trimFields.add(f); if(asBool(r.NormalizeWhitespace)) normWSFields.add(f); if(r.Case) caseRules[f] = parseCaseRule(r.Case); if(r.Regex){ try{ new RegExp(String(r.Regex)); }catch{ badRegexFields.push(f); } } }
  const uniqueTrack = {}; uniqueFields.forEach(f=> uniqueTrack[f] = new Map());

  cleaned.forEach((row,i)=>{
    const idx=i+1;
    const ok = validate(row);
    if(!ok && validate.errors){ for(const err of validate.errors){ issues.push({ row: idx, type:'schema', field: cleanPath(err.instancePath), message: `${err.keyword} ${err.message||'error'}` }); } }
    for(const [field, rx] of Object.entries(regexMap)){ const val = get(row, field); if(val==null||val==='') continue; if(!rx.test(String(val))) issues.push({ row: idx, type:'regex', field, message:`Value "${truncate(String(val))}" does not match ${rx}` }); }
    for(const r of specRows){ const f=(r.Field||'').trim(); if(!f) continue; let val=get(row,f);
      if(asBool(r.Required) && (val==null || String(val).trim()==='')){ issues.push({ row: idx, type:'schema', field:f, message:'Required value missing' }); continue; }
      if(typeof val==='string'){ if(trimFields.has(f) && (val.startsWith(' ')||val.endsWith(' '))){ issues.push({ row: idx, type:'whitespace', field:f, message:'Leading/trailing spaces' }); } if(normWSFields.has(f) && /\s{2,}/.test(val)){ issues.push({ row: idx, type:'whitespace', field:f, message:'Multiple consecutive spaces' }); } }
      if(typeof val==='string' && caseRules[f]){ const expected=applyCase(val, caseRules[f].mode); if(expected!==val){ issues.push({ row: idx, type:'case', field:f, message:`Expected ${caseRules[f].mode} case` }); } }
      if(r.Allowed){ const allowed = splitList(r.Allowed); if(allowed.length && val!=null && String(val).trim()!==''){ const s=String(val); if(!allowed.includes(s)){ const map={}; allowed.forEach(v=> map[v.toLowerCase()]=v); if(map[s.toLowerCase()]){ issues.push({ row: idx, type:'enum', field:f, message:'Adjusted to allowed value (case-insensitive match)' }); } else { issues.push({ row: idx, type:'enum', field:f, message:`Value not in allowed list ${allowed.join('|')}` }); } } } }
      if(r.Regex && val!=null && String(val).trim()!==''){ try{ const rx=new RegExp(String(r.Regex)); if(!rx.test(String(val))) issues.push({ row: idx, type:'regex', field:f, message:`Does not match /${String(r.Regex)}/` }); }catch{ issues.push({ row: idx, type:'spec', field:f, message:'Invalid regex in spec' }); } }
      if(r.Min!=null || r.Max!=null){ const t=String(r.Type||'string').toLowerCase(); if(t==='integer'||t==='number'){ const num=Number(val); if(isFiniteNumber(r.Min) && !(Number.isFinite(num)&&num>=Number(r.Min))) issues.push({ row: idx, type:'range', field:f, message:`Below minimum ${r.Min}` }); if(isFiniteNumber(r.Max) && !(Number.isFinite(num)&&num<=Number(r.Max))) issues.push({ row: idx, type:'range', field:f, message:`Above maximum ${r.Max}` }); } else { const len = (val==null?0:String(val).length); if(isFiniteNumber(r.Min) && len < Number(r.Min)) issues.push({ row: idx, type:'length', field:f, message:`Length < ${r.Min}` }); if(isFiniteNumber(r.Max) && len > Number(r.Max)) issues.push({ row: idx, type:'length', field:f, message:`Length > ${r.Max}` }); } }
      if(uniqueFields.has(f)){ const key=String(val ?? ''); const map=uniqueTrack[f]; const arr=map.get(key)||[]; arr.push(idx); map.set(key,arr); }
    }
  });
  for(const [field, map] of Object.entries(uniqueTrack)){ for(const [key, rows] of map.entries()){ if(key===''||rows.length<=1) continue; issues.push({ row: Math.min(...rows), type:'unique', field, message:`Duplicate value at rows ${rows.join(', ')}` }); } }
  for(const f of badRegexFields) issues.push({ row: 0, type:'spec', field:f, message:'Invalid regex in spec' });

  // Render
  const tb = el('tbody'); tb.innerHTML='';
  for(const e of issues){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${e.row}</td><td>${e.type}</td><td>${e.field||'(root)'}</td><td>${e.message}</td>`; tb.appendChild(tr); }
  setText('state','Done'); el('msg').textContent = issues.length ? `Found ${issues.length} issues across ${dataArray.length} records.` : `No issues across ${dataArray.length} records.`;

  // enable downloads
  el('dlIssues').disabled = issues.length===0;
  el('dlClean').disabled = dataArray.length===0;
  window.__DVC_CLEANED__ = cleaned;
  window.__DVC_ISSUES__ = issues;
}

el('dlIssues').addEventListener('click', ()=>{
  const rows = (window.__DVC_ISSUES__||[]).map(e=>({Row:e.row,Type:e.type,Field:e.field,Message:e.message}));
  downloadCSV(rows, `issues_${Date.now()}`);
});
el('dlClean').addEventListener('click', ()=>{
  const rows = window.__DVC_CLEANED__||[]; downloadCSV(rows, `cleaned_${Date.now()}`);
});

// helpers
function truncate(s, n=80){ s=String(s); return s.length>n ? s.slice(0,n)+'…' : String(s); }
function get(obj, path){ if(!path) return obj; return path.split('.').reduce((o,k)=> o?o[k]:undefined, obj); }
function cleanPath(p){ return String(p||'').replace(/^\//,''); }
function isFiniteNumber(v){ const n=Number(v); return Number.isFinite(n); }
function splitList(v){ return String(v||'').split(/[|,]/).map(s=>s.trim()).filter(Boolean); }
function asBool(v){ if(typeof v==='boolean') return v; const s=String(v||'').toLowerCase(); return (s==='true'||s==='yes'||s==='y'||s==='1'||s==='x'); }
function parseCaseRule(v){ const s=String(v||'').toLowerCase(); if(['upper','lower','title','exact'].includes(s)) return {mode:s}; return {mode:'exact'}; }
function applyCase(s, mode){ if(mode==='upper') return String(s).toUpperCase(); if(mode==='lower') return String(s).toLowerCase(); if(mode==='title') return String(s).replace(/\w\S*/g,(w)=>w[0].toUpperCase()+w.slice(1).toLowerCase()); return s; }

function downloadCSV(rows, name){
  if(!rows||!rows.length) return;
  const csv = Papa.unparse(rows);
  const blob = new Blob([csv], { type:'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`${name}.csv`; a.click(); URL.revokeObjectURL(url);
}
</script>
</body></html>
